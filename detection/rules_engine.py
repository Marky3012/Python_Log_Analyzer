"""
Rules engine for detecting security events in logs.
"""
import os
import yaml
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, DefaultDict
from collections import defaultdict


class RulesEngine:
    """Rules engine for processing security events against detection rules."""
    
    def __init__(self, rules_dir: str = None):
        """
        Initialize the rules engine.
        
        Args:
            rules_dir: Optional directory containing rule YAML files
        """
        self.rules = []
        if rules_dir:
            self.load_rules(rules_dir)
    
    def load_rules(self, rules_dir: str) -> None:
        """
        Load rules from a directory.
        
        Args:
            rules_dir: Directory containing rule YAML files
        """
        self.rules = load_rules_from_dir(rules_dir)
    
    def process_events(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Process events through all loaded rules.
        
        Args:
            events: List of normalized log events
            
        Returns:
            List of alerts generated by the rules
        """
        return run_detection(events, self.rules)


def load_rule(rule_path: str) -> Dict[str, Any]:
    """
    Load a single rule from a YAML file.
    
    Args:
        rule_path: Path to the rule YAML file
        
    Returns:
        Dictionary containing the rule configuration
        
    Raises:
        ValueError: If the rule is invalid or missing required fields
        yaml.YAMLError: If there's an error parsing the YAML
    """
    try:
        with open(rule_path, 'r') as f:
            rule = yaml.safe_load(f)
            
        # Handle case where the rule is a list (take first item)
        if isinstance(rule, list):
            if not rule:
                raise ValueError(f"Rule file {rule_path} is empty")
            rule = rule[0]
            print(f"[!] Warning: Rule file {os.path.basename(rule_path)} contains a list, using first item")
            
        # Ensure the rule is a dictionary
        if not isinstance(rule, dict):
            raise ValueError(f"Rule in {os.path.basename(rule_path)} must be a dictionary")
            
        # Ensure required fields are present
        required_fields = ['id', 'name', 'description', 'severity']
        for field in required_fields:
            if field not in rule:
                raise ValueError(f"Rule in {os.path.basename(rule_path)} is missing required field: {field}")
                
        # Set default values for optional fields
        rule.setdefault('enabled', True)
        rule.setdefault('type', 'standard')
        
        return rule
        
    except yaml.YAMLError as e:
        raise ValueError(f"Error parsing YAML in {os.path.basename(rule_path)}: {str(e)}")
    except Exception as e:
        raise ValueError(f"Error loading rule from {os.path.basename(rule_path)}: {str(e)}")


def load_rules_from_dir(rules_dir: str) -> List[Dict[str, Any]]:
    """
    Load all rules from a directory.
    
    Args:
        rules_dir: Path to directory containing rule YAML files
        
    Returns:
        List of rule configurations
    """
    rules = []
    if not os.path.isdir(rules_dir):
        print(f"[!] Rules directory not found: {rules_dir}")
        return rules
        
    for filename in os.listdir(rules_dir):
        if filename.endswith(('.yaml', '.yml')):
            try:
                rule = load_rule(os.path.join(rules_dir, filename))
                rules.append(rule)
                print(f"[+] Loaded rule: {rule.get('id')} - {rule.get('name')}")
            except Exception as e:
                print(f"[!] Error loading rule from {filename}: {str(e)}")
    
    return rules


def detect_bruteforce(events: List[Dict[str, Any]], rule: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Detect brute force attempts based on the given rule.
    
    Args:
        events: List of normalized log events
        rule: Brute force detection rule configuration
        
    Returns:
        List of alerts generated
    """
    alerts = []
    grouped_events: DefaultDict[str, List[Dict[str, Any]]] = defaultdict(list)
    
    # Filter and group events by the specified field (default: ip)
    group_field = rule.get('group_by', ['ip'])[0]
    
    for event in events:
        # Check if event matches the rule's log source criteria
        if _matches_log_source(event, rule.get('log_source', {})):
            key = event.get(group_field, 'unknown')
            grouped_events[key].append(event)
    
    # Check each group against the threshold
    for key, event_group in grouped_events.items():
        event_count = len(event_group)
        threshold = rule.get('threshold', {}).get('count', 5)
        
        if event_count >= threshold:
            # Get the most recent event for context
            latest_event = max(event_group, key=lambda x: x.get('timestamp', ''))
            
            alert = {
                'rule_id': rule['id'],
                'rule_name': rule['name'],
                'severity': rule['severity'],
                'message': rule['description'],
                'count': event_count,
                'group_field': group_field,
                'group_value': key,
                'first_seen': min(e.get('timestamp') for e in event_group),
                'last_seen': latest_event.get('timestamp'),
                'sample_event': latest_event
            }
            alerts.append(alert)
    
    return alerts


def _matches_log_source(event: Dict[str, Any], log_source: Dict[str, Any]) -> bool:
    """
    Check if an event matches the log source criteria.
    
    Args:
        event: The log event to check
        log_source: Log source criteria from the rule
        
    Returns:
        bool: True if the event matches the criteria, False otherwise
    """
    for field, expected_value in log_source.items():
        if event.get(field) != expected_value:
            return False
    return True


def run_detection(events: List[Dict[str, Any]], rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Run all detection rules against the given events.
    
    Args:
        events: List of normalized log events
        rules: List of rule configurations
        
    Returns:
        List of all alerts generated
    """
    alerts = []
    
    for rule in rules:
        try:
            # Skip if rule is not a dictionary
            if not isinstance(rule, dict):
                print(f"[!] Warning: Skipping invalid rule (not a dictionary): {rule}")
                continue
                
            # Skip disabled rules
            if not rule.get('enabled', True):
                continue
                
            rule_type = rule.get('type', 'standard')
            rule_id = rule.get('id', 'unknown')
            
            print(f"[+] Running rule: {rule_id} ({rule_type})")
            
            # Route to appropriate detection function based on rule type
            if rule_type == 'brute_force':
                alerts.extend(detect_bruteforce(events, rule))
            else:
                # For standard rules, we'd typically do pattern matching
                # This is a placeholder for other rule types
                matches = []
                for event in events:
                    if _event_matches_rule(event, rule):
                        matches.append(event)
                
                if matches:
                    alert = {
                        'rule_id': rule_id,
                        'rule_name': rule.get('name', 'Unnamed Rule'),
                        'severity': rule.get('severity', 'medium'),
                        'description': rule.get('description', ''),
                        'timestamp': datetime.utcnow().isoformat() + 'Z',
                        'events': matches,
                        'count': len(matches)
                    }
                    alerts.append(alert)
                    
        except Exception as e:
            print(f"[!] Error running rule {rule.get('id', 'unknown')}: {str(e)}")
            import traceback
            print(f"Traceback: {traceback.format_exc()}")
            continue
    
    return alerts


def _event_matches_rule(event: Dict[str, Any], rule: Dict[str, Any]) -> bool:
    """
    Check if an event matches the given rule's conditions.
    
    Args:
        event: The event to check
        rule: The rule to match against
        
    Returns:
        bool: True if the event matches the rule, False otherwise
    """
    # This is a simplified version - you'd want to implement more sophisticated
    # pattern matching based on your rule structure
    query = rule.get('query', {})
    
    for field, expected_value in query.items():
        if field not in event:
            return False
            
        actual_value = event[field]
        
        # Handle different comparison operators
        if isinstance(expected_value, dict):
            for op, value in expected_value.items():
                if op == 'equals' and actual_value != value:
                    return False
                elif op == 'contains' and value not in str(actual_value):
                    return False
                # Add more operators as needed
        elif actual_value != expected_value:
            return False
            
    return True
